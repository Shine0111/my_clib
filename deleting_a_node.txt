

BONUS = ft_lstnew.c ft_lstadd_front.c ft_lstsize.c ft_lstlast.c \
	ft_lstadd_back.c ft_lstdelone.c ft_lstclear.c ft_lstiter.c ft_lstmap.c

OBJS =	$(SRC:.c=.o)
BONUS_OBJS = $(BONUS:.c=.o)

CC = cc
RM = rm -f
CFLAGS = -Wall -Wextra -Werror
AR = ar rcs
INCLUDE = -I .

all: $(NAME)

.o:.c
	$(CC) $(CFLAGS) $(INCLUDE) -c $<

$(NAME): $(OBJS)
	$(AR) $(NAME) $(OBJS)

bonus: $(OBJS) $(BONUS_OBJS)
	$(AR) $(NAME) $(OBJS) $(BONUS_OBJS)

clean:	
	$(RM) $(OBJS) $(BONUS_OBJS)

fclean: clean
	$(RM) $(NAME)

re: fclean all

.PHONY: all bonus clean fclean re


Why Use a Temporary Variable?Preserve Access to the Node:When you call (*del)(lst->content);, the del function frees the memory allocated for the nodeâ€™s content. After this, the nodeâ€™s content pointer is no longer valid.However, the node itself (lst) is still valid and needs to be freed using free(lst).If you donâ€™t store the node in a temporary variable (tmp), you risk losing access to the node after freeing its content.Avoid Dangling Pointers:If you free the nodeâ€™s content and then try to access the node (e.g., to free it), you might encounter undefined behavior because the nodeâ€™s content pointer is no longer valid.By storing the node in tmp, you ensure that you still have a valid reference to the node even after freeing its content.Logical Separation:Using a temporary variable makes the code more readable and logical. It clearly separates the steps:Step 1: Free the nodeâ€™s content.Step 2: Free the node itself.What Happens Without a Temporary Variable?If you donâ€™t use a temporary variable, the code might look like this:cCopyvoid ft_lstdelone(t_list *lst, void (*del)(void *)){    if (!lst)        return;    (*del)(lst->content);  // Free the node's content    free(lst);             // Free the node itself}At first glance, this seems fine. However, thereâ€™s a subtle issue:After calling (*del)(lst->content);, the content pointer in the node is no longer valid. If the del function modifies the nodeâ€™s content pointer (e.g., sets it to NULL), accessing lst afterward could lead to undefined behavior.While this might work in some cases, itâ€™s not safe or reliable. Using a temporary variable ensures that the node itself is still accessible and valid when you call free(lst).Example WalkthroughLetâ€™s say we have the following node:cCopyt_list *node = malloc(sizeof(t_list));node->content = malloc(10);  // Allocate memory for contentnode->next = NULL;Now, letâ€™s see what happens when we call ft_lstdelone(node, del);:With Temporary Variable (tmp):tmp = lst; â†’ tmp now points to the node.(*del)(lst->content); â†’ The del function frees the memory for content.free(tmp); â†’ The memory for the node itself is freed.This works correctly and safely.Without Temporary Variable:(*del)(lst->content); â†’ The del function frees the memory for content.free(lst); â†’ The memory for the node itself is freed.This might work, but itâ€™s not safe because:If the del function modifies lst->content (e.g., sets it to NULL), accessing lst afterward could cause issues.Itâ€™s also less clear and harder to debug.Key TakeawaysSafety:Using a temporary variable ensures that you always have a valid reference to the node, even after freeing its content.Readability:The temporary variable makes the code more readable and separates the steps logically.Avoid Undefined Behavior:Without a temporary variable, you risk accessing invalid memory, which can lead to crashes or undefined behavior.Improved Code with CommentsHereâ€™s the improved version of the function with comments to highlight the importance of the temporary variable:cCopyvoid ft_lstdelone(t_list *lst, void (*del)(void *)){    t_list *tmp;    if (!lst)           // Check if the node is NULL        return;    tmp = lst;          // Store the node in a temporary variable    (*del)(lst->content);  // Call the deletion function to free the node's content    free(tmp);          // Free the memory allocated for the node itself}SummaryThe temporary variable (tmp) is used to preserve access to the node after freeing its content.It ensures safety and reliability by avoiding undefined behavior.It makes the code more readable and logical.ðŸ˜ŠLetâ€™s break down the `ft_lstmap` function step by step and explain its logic. This function is used to **create a new linked list** by applying a function (`f`) to the **content** of each node in an existing list. If any operation fails, it cleans up and returns `NULL`.---### Purpose of the FunctionThe `ft_lstmap` function:1. Iterates over an existing linked list (`lst`).2. Applies a function (`f`) to the content of each node.3. Creates a new node with the transformed content.4. Adds the new node to a new linked list.5. If any step fails (e.g., memory allocation fails), it cleans up and returns `NULL`.---### Code Breakdown```ct_list *ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *)){    t_list *new_lst;  // Pointer to the new list    t_list *content;  // Transformed content    t_list *node;     // New node to be added to the new list    new_lst = NULL;   // Initialize the new list as empty    if (!lst || !f || !del)  // Check for NULL inputs        return (NULL);    while (lst != NULL)  // Traverse the original list    {        content = f(lst->content);  // Apply the function to the current node's content        node = ft_lstnew(content);  // Create a new node with the transformed content        if (!node)  // Check if node creation failed        {            del(content);  // Free the transformed content            ft_lstclear(&new_lst, del);  // Free the entire new list            return (NULL);  // Return NULL to indicate failure        }        ft_lstadd_back(&new_lst, node);  // Add the new node to the new list        lst = lst->next;  // Move to the next node in the original list    }    return (new_lst);  // Return the new list}```---### Step-by-Step Explanation1. **Initialize the New List**:   - `new_lst = NULL;`     - The new list is initialized as empty.2. **Check for NULL Inputs**:   - `if (!lst || !f || !del) return (NULL);`     - If the original list (`lst`), the function (`f`), or the deletion function (`del`) is `NULL`, the function returns `NULL` immediately.3. **Traverse the Original List**:   - `while (lst != NULL)`     - The `while` loop iterates over each node in the original list.4. **Apply the Function to the Content**:   - `content = f(lst->content);`     - The function `f` is applied to the current nodeâ€™s content. This transforms the content and returns a new value.     - For example, if `f` is a function that duplicates a string, `content` will point to the duplicated string.5. **Create a New Node**:   - `node = ft_lstnew(content);`     - A new node is created using the transformed content.     - If `ft_lstnew` fails (e.g., due to memory allocation failure), `node` will be `NULL`.6. **Handle Node Creation Failure**:   - `if (!node)`     - If node creation fails:       - `del(content);` â†’ Free the transformed content.       - `ft_lstclear(&new_lst, del);` â†’ Free the entire new list created so far.       - `return (NULL);` â†’ Return `NULL` to indicate failure.7. **Add the New Node to the New List**:   - `ft_lstadd_back(&new_lst, node);`     - The new node is added to the end of the new list.8. **Move to the Next Node**:   - `lst = lst->next;`     - The pointer `lst` is updated to point to the next node in the original list.9. **Return the New List**:   - `return (new_lst);`     - After processing all nodes, the function returns the new list.---### Example WalkthroughLetâ€™s say we have the following linked list:```Node 1 -> Node 2 -> Node 3 -> NULL```Each nodeâ€™s content is a string:- `Node 1->content = "Hello"`- `Node 2->content = "World"`- `Node 3->content = "!"`We want to apply a function `duplicate_string` to each nodeâ€™s content. The `duplicate_string` function looks like this:```cvoid *duplicate_string(void *content){    char *str = (char *)content;    char *dup = strdup(str);  // Duplicate the string    return (dup);  // Return the duplicated string}```Now, letâ€™s see how `ft_lstmap` works:1. **Initialize the New List**:   - `new_lst = NULL;`2. **First Iteration**:   - `lst` points to `Node 1`.   - `content = f(lst->content);` â†’ `content = duplicate_string("Hello")` â†’ `content = "Hello"` (duplicated).   - `node = ft_lstnew(content);` â†’ A new node is created with `content = "Hello"`.   - `ft_lstadd_back(&new_lst, node);` â†’ The new node is added to the new list.   - `lst = lst->next;` â†’ Move to `Node 2`.3. **Second Iteration**:   - `lst` points to `Node 2`.   - `content = f(lst->content);` â†’ `content = duplicate_string("World")` â†’ `content = "World"` (duplicated).   - `node = ft_lstnew(content);` â†’ A new node is created with `content = "World"`.   - `ft_lstadd_back(&new_lst, node);` â†’ The new node is added to the new list.   - `lst = lst->next;` â†’ Move to `Node 3`.4. **Third Iteration**:   - `lst` points to `Node 3`.   - `content = f(lst->content);` â†’ `content = duplicate_string("!")` â†’ `content = "!"` (duplicated).   - `node = ft_lstnew(content);` â†’ A new node is created with `content = "!"`.   - `ft_lstadd_back(&new_lst, node);` â†’ The new node is added to the new list.   - `lst = lst->next;` â†’ Move to `NULL`.5. **End of Loop**:   - The loop ends because `lst` is now `NULL`.6. **Return the New List**:   - The function returns the new list:     ```     New Node 1 -> New Node 2 -> New Node 3 -> NULL     ```     - `New Node 1->content = "Hello"`     - `New Node 2->content = "World"`     - `New Node 3->content = "!"`---### Key Points1. **Function Pointer (`f`)**:   - The function `f` is applied to the content of each node to transform it.   - For example, `f` could duplicate strings, convert data types, or perform other transformations.2. **Deletion Function (`del`)**:   - The `del` function is used to free the transformed content if node creation fails.   - It is also used by `ft_lstclear` to free the entire new list if an error occurs.3. **Error Handling**:   - If `ft_lstnew` fails (e.g., due to memory allocation failure), the function cleans up:     - Frees the transformed content.     - Frees the entire new list created so far.     - Returns `NULL` to indicate failure.4. **Time Complexity**:   - The time complexity is **O(n)**, where `n` is the number of nodes in the original list, because the function processes each node once.---### Example Use Cases1. **Duplicating a List**:   - Use `ft_lstmap` to create a copy of a list with duplicated content.2. **Transforming Data**:   - Use `ft_lstmap` to apply a transformation (e.g., converting strings to uppercase) to each nodeâ€™s content.3. **Filtering Data**:   - Use `ft_lstmap` to create a new list containing only nodes that meet certain criteria (e.g., filtering out NULL values).---### Summary- The `ft_lstmap` function creates a new linked list by applying a function (`f`) to the content of each node in an existing list.- It handles errors gracefully by cleaning up and returning `NULL` if any operation fails.- The time complexity is **O(n)** because it processes each node once.
